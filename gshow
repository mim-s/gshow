#!/usr/bin/env bash

# Future me attention:
#   There are exactly 5 global variables and they are in capitals:
#   VERBOSE_OPT, ID_OPT, DELIMITER, GID_PRIMARY_USERS, USERNAME_UID
#   GID_PRIMARY_USERS is only used in print_primary_users().
#   USERNAME_UID is only used in print_supplementary_users().
#
#   usage() and error() are only called in main().


usage() {
  cat << 'EOF'
Usage: gshow [OPTION]... [GROUP]
Show information about groups.

GROUP may be a group name or GID.

With no GROUP, output all regular groups.

With GROUP, output exactly two lines:
  1. users whose primary group is GROUP
  2. users with GROUP as a supplementary group

Options:
  -v, --verbose            show all regular groups in verbose format
  -e, --empty              show regular groups with no members
                           no output if there are none
  -p, --primary            show users whose primary group is GROUP
                           no output if there are none
  -s, --supplementary      show users with GROUP as a supplementary group
                           no output if there are none
  -i, --id                 also print UIDs/GIDs
  -d, --delimiter=DELIM    set output delimiter (default: space)
      --help               display this help and exit

Exit status:
  0     if OK,
  1     if the syntax is not followed,
  2     if GROUP does not exist.
EOF
}

error() {
  local status="$1" msg="$2"
  local default_msg="gshow: invalid syntax.\nTry 'gshow --help' for more information.\n"

  printf '%b' "${msg:-$default_msg}" >&2
  exit "$status"
}

get_min_max_gid() {
  local mingid maxgid key value
  while read -r key value _; do
    case "$key" in
      GID_MIN) mingid="$value" ;;
      GID_MAX) maxgid="$value" ;;
    esac
  done 2>/dev/null < '/etc/login.defs'

  mingid="${mingid:-1000}"
  maxgid="${maxgid:-60000}"

  printf '%s %s\n' "$mingid" "$maxgid"
}

generate_regular_group_lines() {
  local mingid maxgid name x gid supps
  read -r mingid maxgid < <(get_min_max_gid)

  while IFS=':' read -r name x gid supps; do
    (( gid < mingid || gid > maxgid )) && continue
    printf '%s:%s:%s:%s\n' "$name" "$x" "$gid" "$supps" # To avoid *cut*.
  done < <(getent group)
}

print_primary_users() {
  local target_gid="$1"
  declare -gA GID_PRIMARY_USERS

  # To avoid calling *getent passwd* for each group.
  if (( ${#GID_PRIMARY_USERS[@]} == 0 )); then
    local username uid gid
    while IFS=':' read -r username _ uid gid _; do
      if [[ -v GID_PRIMARY_USERS["$gid"] ]]; then
        GID_PRIMARY_USERS["$gid"]+="$DELIMITER"
      fi

      GID_PRIMARY_USERS["$gid"]+="$username"
      (( ID_OPT )) && GID_PRIMARY_USERS["$gid"]+="($uid)"
    done < <(getent passwd)
  fi

  printf '%s' "${GID_PRIMARY_USERS[$target_gid]}"
  if [[ -v GID_PRIMARY_USERS["$target_gid"] ]] || (( VERBOSE_OPT )); then
    printf '\n'
  fi
}

print_supplementary_users() {
  local supps="$1"
  if [[ -z "$supps" ]]; then
    (( VERBOSE_OPT )) && printf '\n'
    return
  fi

  if (( ID_OPT )); then
    local sep='' username uid
    declare -gA USERNAME_UID

    # To avoid calling *id -u* for every username
    if (( ${#USERNAME_UID[@]} == 0 )); then
      while IFS=':' read -r username _ uid _; do
        USERNAME_UID["$username"]="$uid"
      done < <(getent passwd)
    fi
    while read -r username; do
      [[ -v USERNAME_UID["$username"] ]] || continue    # In a clean system, *continue* should never happen.

      printf '%s%s(%s)' "$sep" "$username" "${USERNAME_UID[$username]}"
      sep="$DELIMITER"
    done <<< "${supps//,/$'\n'}"

  else
    printf '%s' "${supps//,/$DELIMITER}"
  fi
  printf '\n'
}

# $1 is the GID, $2 is its supp members.
verbose_group() {
  print_primary_users "$1"
  print_supplementary_users "$2"
}

all_groups() {
  local sep='' groupname gid supps

  while IFS=':' read -r groupname _ gid supps; do
    if (( VERBOSE_OPT )); then
      printf '%s' "$groupname"
      (( ID_OPT )) && printf '(%s)' "$gid"
      printf ':\n'
      verbose_group "$gid" "$supps"
      printf -- '----------\n'
    else
      printf '%s%s' "$sep" "$groupname"
      (( ID_OPT )) && printf '(%s)' "$gid"
      sep="$DELIMITER"
    fi
  done < <(generate_regular_group_lines)
  (( ! VERBOSE_OPT )) && printf '\n'
}

empty_groups() {
  local gid
  local -A used_gids=()

  # To avoid calling *getent passwd* for each group.
  while IFS=':' read -r _ _ _ gid _; do
    used_gids["$gid"]=1
  done < <(getent passwd)

  local sep='' found=0 groupname supps
  while IFS=':' read -r groupname _ gid supps; do
    [[ -n "$supps" ]]          && continue
    [[ -v used_gids["$gid"] ]] && continue

    found=1
    printf '%s%s' "$sep" "$groupname"
    (( ID_OPT )) && printf '(%s)' "$gid"
    sep="$DELIMITER"
  done < <(generate_regular_group_lines)
  (( found )) && printf '\n'
}

# Only called in main(). $1 is group name or GID.
get_gid_and_supps() {
  local group_line gid supps
  group_line="$(getent group "$1")" || return 2

  IFS=':' read -r _ _ gid supps <<< "$group_line"
  printf '%s %s\n' "$gid" "$supps"
}

main() {
  local temp_args
  temp_args="$(getopt -q -o vepsid: \
      -l verbose,empty,primary,supplementary,id,delimiter:,help -- "$@")" || error 1
  eval set -- "$temp_args"

  VERBOSE_OPT=0
  ID_OPT=0
  DELIMITER=' '
  local empty_opt=0 primary_opt=0 supplementary_opt=0
  while :; do
    case "$1" in
      -v|--verbose)       VERBOSE_OPT=1;       shift    ;;
      -e|--empty)         empty_opt=1;         shift    ;;
      -p|--primary)       primary_opt=1;       shift    ;;
      -s|--supplementary) supplementary_opt=1; shift    ;;
      -i|--id)            ID_OPT=1;            shift    ;;
      -d|--delimiter)     DELIMITER="$2";      shift  2 ;;
      --help)             usage;               return 0 ;;
      --)                 shift;               break    ;;
    esac
  done

  if (( $# == 0 )); then
    (( primary_opt || supplementary_opt )) && error 1
    (( VERBOSE_OPT && empty_opt ))         && error 1

    if (( empty_opt )); then
      empty_groups
    else
      all_groups
    fi
    return

  elif (( $# == 1 )); then
    (( VERBOSE_OPT || empty_opt ))         && error 1
    (( primary_opt && supplementary_opt )) && error 1

    local out
    out="$(get_gid_and_supps "$1")"        || error 2 "Group \"$1\" does not exist.\n"

    local gid supps
    read -r gid supps <<< "$out"

    if (( primary_opt )); then
      print_primary_users "$gid"
    elif (( supplementary_opt )); then
      print_supplementary_users "$supps"
    else
      VERBOSE_OPT=1
      verbose_group "$gid" "$supps"
    fi
    return

  else
    error 1
  fi
}

main "$@"
